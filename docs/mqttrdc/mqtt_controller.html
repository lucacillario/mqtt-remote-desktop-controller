<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>mqttrdc.mqtt_controller API documentation</title>
<meta name="description" content="MQTT Remote Desktop Controller …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mqttrdc.mqtt_controller</code></h1>
</header>
<section id="section-intro">
<p>MQTT Remote Desktop Controller.</p>
<p>This module lets the user to remotely control some multimedia functionalities of his
desktop/laptop, using the MQTT protocol.</p>
<p>Two MQTT topics:</p>
<ol>
<li>
<p><code>MQTT_CONTROL_TOPIC</code>: used to receive commands from the user.
Commands are expected to be in JSON format.</p>
</li>
<li>
<p><code>MQTT_STATUS_TOPIC</code>: used to notify the user of status updates (volume/mute).
Status updates are sent in JSON format.</p>
</li>
</ol>
<h2 id="examples">Examples</h2>
<p>Below is the list of supported commands, in JSON format:</p>
<p>Sets the volume to 100%:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; {&quot;volume&quot;: 100}
</code></pre>
<p>Increases and decreases the volume by <code>VOLUME_STEP</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; {&quot;volumeCtrl&quot;: &quot;+&quot;}
&gt;&gt;&gt; {&quot;volumeCtrl&quot;: &quot;-&quot;}
</code></pre>
<p>Mute and unmute:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; {&quot;mute&quot;: true}
&gt;&gt;&gt; {&quot;mute&quot;: false}
</code></pre>
<p>Toggle mute/unmute and play/pause:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; {&quot;toggle&quot;: &quot;mute&quot;}
&gt;&gt;&gt; {&quot;toggle&quot;: &quot;pause&quot;}
</code></pre>
<p>Skip forward/backward:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; {&quot;ctrl&quot;: &quot;&gt;&gt;&quot;}
&gt;&gt;&gt; {&quot;ctrl&quot;: &quot;&lt;&lt;&quot;}
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;MQTT Remote Desktop Controller.

This module lets the user to remotely control some multimedia functionalities of his
desktop/laptop, using the MQTT protocol.

Two MQTT topics:

1. `MQTT_CONTROL_TOPIC`: used to receive commands from the user.
    Commands are expected to be in JSON format.

2. `MQTT_STATUS_TOPIC`: used to notify the user of status updates (volume/mute).
    Status updates are sent in JSON format.

Examples
--------
Below is the list of supported commands, in JSON format:

Sets the volume to 100%:
&gt;&gt;&gt; {&#34;volume&#34;: 100}

Increases and decreases the volume by `VOLUME_STEP`:
&gt;&gt;&gt; {&#34;volumeCtrl&#34;: &#34;+&#34;}
&gt;&gt;&gt; {&#34;volumeCtrl&#34;: &#34;-&#34;}

Mute and unmute:
&gt;&gt;&gt; {&#34;mute&#34;: true}
&gt;&gt;&gt; {&#34;mute&#34;: false}

Toggle mute/unmute and play/pause:
&gt;&gt;&gt; {&#34;toggle&#34;: &#34;mute&#34;}
&gt;&gt;&gt; {&#34;toggle&#34;: &#34;pause&#34;}


Skip forward/backward:
&gt;&gt;&gt; {&#34;ctrl&#34;: &#34;&gt;&gt;&#34;}
&gt;&gt;&gt; {&#34;ctrl&#34;: &#34;&lt;&lt;&#34;}
&#34;&#34;&#34;

from json import JSONDecodeError
from alsaaudio import ALSAAudioError, Mixer as ALSAMixer
import paho.mqtt.client as mqtt
from paho.mqtt.properties import Properties
import json
from jsonschema import validate, ValidationError
import logging
import sys
import time
from typing import Any
from mqttrdc.mqtt_controller_manager import MQTTControllerManager

# to run the unittest in an environment without a display Server
try:
    from pynput.keyboard import Key, Controller as KeyboardController
except ImportError as e:
    if __name__ == &#34;__main__&#34;:
        raise
    else:
        print(f&#34;Cannot import pynput: {e}&#34;)
        Key = None
        KeyboardController = None


class MQTTController:
    &#34;&#34;&#34;A class used to remote control some desktop functionalities over MQTT protocol.

    Attributes
    ----------
    volume_schema: dict
        JSON Schema of volume commands
    volume_ctrl_schema: dict
        JSON Schema of volume ctrl commands
    mute_schema: dict
        JSON Schema of mute commands
    toggle_schema: dict
        JSON Schema of toggle commands
    audio_mixer: `alsaaudio.Mixer`
        Used to control desktop volume
    keyboard: `pynput.keyboard.Controller`
        Used to simulate keyboard actions
    mqttc: `paho.mqtt.client.Client`
        MQTT client
    config: `MQTTControllerManager`
        Configuration manager, used to configure instances of this class
    &#34;&#34;&#34;

    volume_schema = {
        &#34;type&#34;: &#34;object&#34;,
        &#34;properties&#34;: {&#34;volume&#34;: {&#34;type&#34;: &#34;integer&#34;, &#34;minimum&#34;: 0, &#34;maximum&#34;: 100}},
    }

    volume_ctrl_schema = {
        &#34;type&#34;: &#34;object&#34;,
        &#34;properties&#34;: {&#34;volumeCtrl&#34;: {&#34;type&#34;: &#34;string&#34;, &#34;enum&#34;: [&#34;+&#34;, &#34;-&#34;]}},
    }

    mute_schema = {
        &#34;type&#34;: &#34;object&#34;,
        &#34;properties&#34;: {&#34;mute&#34;: {&#34;type&#34;: &#34;boolean&#34;}},
    }

    toggle_schema = {
        &#34;type&#34;: &#34;object&#34;,
        &#34;properties&#34;: {&#34;toggle&#34;: {&#34;type&#34;: &#34;string&#34;, &#34;enum&#34;: [&#34;mute&#34;, &#34;pause&#34;]}},
    }

    ctrl_schema = {
        &#34;type&#34;: &#34;object&#34;,
        &#34;properties&#34;: {&#34;ctrl&#34;: {&#34;type&#34;: &#34;string&#34;, &#34;enum&#34;: [&#34;&gt;&gt;&#34;, &#34;&lt;&lt;&#34;]}},
    }

    def __init__(self):
        # to run the unittest in an environment without an audio device
        try:
            self.audio_mixer = ALSAMixer()
        except ALSAAudioError as alsa_error:
            if __name__ == &#34;__main__&#34;:
                raise
            else:
                print(f&#34;No audio device: {alsa_error}&#34;)
                self.audio_mixer = None
        self.keyboard = KeyboardController() if KeyboardController else None
        self.mqttc = mqtt.Client()
        self.mqttc.on_connect = self.on_connect
        self.mqttc.on_publish = self.on_publish
        self.mqttc.on_subscribe = self.on_subscribe
        self.mqttc.on_message = self.on_message
        self.mqttc.on_disconnect = self.on_disconnect
        self.config = MQTTControllerManager()

    def on_connect(
        self,
        client: mqtt.Client,
        userdata: Any,
        flags: dict,
        rc: int,
        properties: Properties = None,
    ) -&gt; None:
        &#34;&#34;&#34;Defines the `on_connect` callback implementation.

        See `paho.mqtt.client.Client.on_connect` for more information.
        &#34;&#34;&#34;
        if rc == 0:
            logging.info(
                f&#34;Successfully connected to the broker {self.config.broker}: flags={flags}, properties={properties}&#34;
            )
        else:
            logging.error(
                f&#34;Cannot connect to the broker {self.config.broker}: error code={rc}&#34;
            )

    @staticmethod
    def on_publish(client: mqtt.Client, userdata: Any, mid: int) -&gt; None:
        &#34;&#34;&#34;Defines the `on_publish` callback implementation.

        See `paho.mqtt.client.Client.on_publish` for more information.
        &#34;&#34;&#34;
        logging.info(f&#34;Successfully published a message: mid={mid}&#34;)

    @staticmethod
    def on_subscribe(
        client: mqtt.Client,
        userdata: Any,
        mid: int,
        granted_qos: int,
        properties: Properties = None,
    ) -&gt; None:
        &#34;&#34;&#34;Defines the `on_subscribe` callback implementation.

        See `paho.mqtt.client.Client.on_subscribe` for more information.
        &#34;&#34;&#34;
        logging.info(
            f&#34;Successfully subscribed to topic: mid={mid}, granted qos={granted_qos}, properties={properties}&#34;
        )

    def handle_message(self, msg: mqtt.MQTTMessage) -&gt; None:
        &#34;&#34;&#34;Processes the received message and performs the corresponding action.

        Parameters
        ----------
        msg: `paho.mqtt.client.MQTTMessage`
            The received message to process

        Raises
        ------
        UnicodeDecodeError
            if message decoding fails
        JSONDecodeError
            if message JSON decoding fails
        ValidationError
            if message JSON Schema validation fails
        ValueError
            if message contains an invalid command
        &#34;&#34;&#34;
        payload = json.loads(msg.payload.decode(&#34;utf-8&#34;))
        logging.info(f&#34;Received a new message: {payload}&#34;)
        if &#34;volume&#34; in payload:
            validate(payload, schema=self.volume_schema)
            self.volume = payload[&#34;volume&#34;]
        elif &#34;volumeCtrl&#34; in payload:
            validate(payload, schema=self.volume_ctrl_schema)
            self.volume_up() if payload[&#34;volumeCtrl&#34;] == &#34;+&#34; else self.volume_down()
        elif &#34;mute&#34; in payload:
            validate(payload, schema=self.mute_schema)
            self.mute = payload[&#34;mute&#34;]
        elif &#34;toggle&#34; in payload:
            validate(payload, schema=self.toggle_schema)
            self.toggle_mute() if payload[&#34;toggle&#34;] == &#34;mute&#34; else self.toggle_pause()
        elif &#34;ctrl&#34; in payload:
            validate(payload, schema=self.ctrl_schema)
            self.skip_forward() if payload[&#34;ctrl&#34;] == &#34;&gt;&gt;&#34; else self.skip_backward()
        else:
            raise ValueError(f&#34;Cannot handle message: {payload}, not a valid command&#34;)

    def on_message(
        self, client: mqtt.Client, userdata: Any, msg: mqtt.MQTTMessage
    ) -&gt; None:
        &#34;&#34;&#34;Defines the `on_message` callback implementation.

        See `paho.mqtt.client.Client.on_message` for more information.
        &#34;&#34;&#34;
        try:
            self.handle_message(msg)
        except UnicodeDecodeError as e:
            logging.error(f&#34;Cannot decode message: {msg.payload}, {e}&#34;)
        except JSONDecodeError:
            logging.error(
                f&#34;Cannot deserialize message: {msg.payload.decode(&#39;utf-8&#39;)}, not a valid JSON&#34;
            )
        except ValidationError as e:
            logging.error(f&#34;Invalid JSON Schema: {e.message}&#34;)
        except ValueError as e:
            logging.error(str(e))
        except Exception as e:
            logging.error(f&#34;Unexpected error while receiving a new message: {e}&#34;)

    def on_disconnect(self, client: mqtt.Client, userdata: Any, rc: int) -&gt; None:
        &#34;&#34;&#34;Defines the `on_disconnect` callback implementation.

        See `paho.mqtt.client.Client.on_disconnect` for more information.
        &#34;&#34;&#34;
        if rc == mqtt.MQTT_ERR_SUCCESS:
            logging.info(
                f&#34;Successfully disconnected from the broker {self.config.broker}&#34;
            )
            sys.exit(0)
        else:
            logging.critical(
                f&#34;Unexpected disconnection from the broker {self.config.broker}: error code={rc}&#34;
            )
            sys.exit(1)

    @property
    def volume(self) -&gt; int:
        &#34;&#34;&#34;Gets the current volume.

        Returns
        -------
        int
            current volume integer percentage
        &#34;&#34;&#34;
        return self.audio_mixer.getvolume()[0]

    @volume.setter
    def volume(self, value: int) -&gt; None:
        &#34;&#34;&#34;Sets the volume.

        Parameters
        ----------
        value: int
            volume integer percentage
        &#34;&#34;&#34;
        self.audio_mixer.setvolume(value)
        self.update_status()

    def volume_up(self) -&gt; None:
        &#34;&#34;&#34;Increases the volume.

        The volume is increased by `VOLUME_STEP`, given in the configurations file.
        &#34;&#34;&#34;
        self.volume = min(self.volume + self.config.volume_step, 100)

    def volume_down(self) -&gt; None:
        &#34;&#34;&#34;Decreases the volume.

        The volume is decreased by `VOLUME_STEP`, given in the configurations file.
        &#34;&#34;&#34;
        self.volume = max(self.volume - self.config.volume_step, 0)

    @property
    def mute(self) -&gt; bool:
        &#34;&#34;&#34;Gets the mute status.

        Returns
        -------
        bool
            True if mute, False otherwise
        &#34;&#34;&#34;
        return bool(self.audio_mixer.getmute()[0])

    @mute.setter
    def mute(self, value: bool) -&gt; None:
        &#34;&#34;&#34;Sets the mute status.

        Parameters
        ----------
        value: bool
            updated mute status
        &#34;&#34;&#34;
        self.audio_mixer.setmute(value)
        self.update_status()

    def toggle_mute(self) -&gt; None:
        &#34;&#34;&#34;Toggle mute status.&#34;&#34;&#34;
        self.mute = not self.mute

    def toggle_pause(self) -&gt; None:
        &#34;&#34;&#34;Toggle play/pause status by simulating a space bar press.&#34;&#34;&#34;
        self.keyboard.press(Key.space)
        self.keyboard.release(Key.space)

    def skip_forward(self) -&gt; None:
        &#34;&#34;&#34;Skip forward.

        How much the content will be skipped forward is platform dependant (usually 10 seconds).
        &#34;&#34;&#34;
        self.keyboard.press(Key.right)
        self.keyboard.release(Key.right)

    def skip_backward(self) -&gt; None:
        &#34;&#34;&#34;Skip backward.

        How much the content will be skipped backward is platform dependant (usually 10 seconds).
        &#34;&#34;&#34;
        self.keyboard.press(Key.left)
        self.keyboard.release(Key.left)

    @property
    def status(self) -&gt; dict:
        &#34;&#34;&#34;Gets the current status.

        Returns
        -------
        dict
            a dictionary containing the current volume/mute status

        Notes
        -----
        `play/pause` status is not included here because there is no way
        to actually maintain an always up-to-date status.
        &#34;&#34;&#34;
        return {&#34;volume&#34;: self.volume, &#34;mute&#34;: self.mute}

    def update_status(self) -&gt; None:
        &#34;&#34;&#34;Publishes on `MQTT_STATUS_TOPIC` the current status (volume/mute).&#34;&#34;&#34;
        try:
            (rc, mid) = self.mqttc.publish(
                self.config.status_topic, json.dumps(self.status), qos=0, retain=False
            )
            if rc == mqtt.MQTT_ERR_SUCCESS:
                logging.info(
                    f&#34;The request for a status update has been successfully accepted: mid={mid}&#34;
                )
            else:
                logging.warning(&#34;The request for a status update has been rejected&#34;)
        except ValueError as e:
            logging.warning(f&#34;Cannot send status update: {e}&#34;)

    def start(self) -&gt; None:
        &#34;&#34;&#34;Starts the MQTT client and subscribes to `MQTT_CONTROL_TOPIC` to receive commands.&#34;&#34;&#34;
        # Set logging level
        debug_level = logging.DEBUG if self.config.debug else logging.ERROR
        logging.basicConfig(
            format=&#34;[%(asctime)s] %(levelname)-8s %(message)s&#34;, level=debug_level
        )

        try:
            # Check if authentication is required for connecting to the broker
            if self.config.user and self.config.password:
                self.mqttc.username_pw_set(
                    username=self.config.user, password=self.config.password
                )

            # Connect to the broker
            self.mqttc.connect(self.config.broker, self.config.port, keepalive=60)

            # Subscribe to the control topic, used to receive commands
            (rc, mid) = self.mqttc.subscribe(self.config.control_topic, qos=0)
            if rc == mqtt.MQTT_ERR_SUCCESS:
                logging.info(
                    f&#34;The request for control topic subscription has been successfully accepted: mid={mid}&#34;
                )
            else:
                logging.warning(
                    &#34;The request for control topic subscription has been rejected&#34;
                )

            # Check if status updates should be sent periodically
            if self.config.status_update_delay:
                self.mqttc.loop_start()
                while True:
                    self.update_status()
                    time.sleep(self.config.status_update_delay)
            else:
                self.mqttc.loop_forever()
        except ConnectionError as e:
            logging.critical(f&#34;Connection failed: {e}&#34;)
            sys.exit(1)
        except ValueError as e:
            logging.critical(
                f&#34;Cannot subscribe to topic {self.config.control_topic}: {e}&#34;
            )
            sys.exit(1)
        except Exception as e:
            logging.critical(f&#34;Unexpected error while starting the controller: {e}&#34;)
            sys.exit(1)

    def stop(self) -&gt; None:
        &#34;&#34;&#34;Stops the MQTT client and disconnects from the broker.&#34;&#34;&#34;
        self.mqttc.disconnect()


if __name__ == &#34;__main__&#34;:
    drc = MQTTController()

    import os
    from os.path import dirname, join, exists
    from dotenv import load_dotenv

    env_path = join(join(dirname(__file__), os.pardir), &#34;.env&#34;)
    if exists(env_path):
        load_dotenv(env_path)

    # `Config` should be imported after loading the `.env` file
    from mqttrdc.config import Config

    drc.config.from_object(Config)

    try:
        drc.start()
    finally:
        # gracefully stops the client, for example when receives a `KeyboardInterrupt` (e.g. CTRL + c)
        drc.stop()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mqttrdc.mqtt_controller.MQTTController"><code class="flex name class">
<span>class <span class="ident">MQTTController</span></span>
</code></dt>
<dd>
<div class="desc"><p>A class used to remote control some desktop functionalities over MQTT protocol.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>volume_schema</code></strong> :&ensp;<code>dict</code></dt>
<dd>JSON Schema of volume commands</dd>
<dt><strong><code>volume_ctrl_schema</code></strong> :&ensp;<code>dict</code></dt>
<dd>JSON Schema of volume ctrl commands</dd>
<dt><strong><code>mute_schema</code></strong> :&ensp;<code>dict</code></dt>
<dd>JSON Schema of mute commands</dd>
<dt><strong><code>toggle_schema</code></strong> :&ensp;<code>dict</code></dt>
<dd>JSON Schema of toggle commands</dd>
<dt><strong><code>audio_mixer</code></strong> :&ensp;<code>alsaaudio.Mixer</code></dt>
<dd>Used to control desktop volume</dd>
<dt><strong><code>keyboard</code></strong> :&ensp;<code>pynput.keyboard.Controller</code></dt>
<dd>Used to simulate keyboard actions</dd>
<dt><strong><code>mqttc</code></strong> :&ensp;<code>paho.mqtt.client.Client</code></dt>
<dd>MQTT client</dd>
<dt><strong><code>config</code></strong> :&ensp;<code>MQTTControllerManager</code></dt>
<dd>Configuration manager, used to configure instances of this class</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MQTTController:
    &#34;&#34;&#34;A class used to remote control some desktop functionalities over MQTT protocol.

    Attributes
    ----------
    volume_schema: dict
        JSON Schema of volume commands
    volume_ctrl_schema: dict
        JSON Schema of volume ctrl commands
    mute_schema: dict
        JSON Schema of mute commands
    toggle_schema: dict
        JSON Schema of toggle commands
    audio_mixer: `alsaaudio.Mixer`
        Used to control desktop volume
    keyboard: `pynput.keyboard.Controller`
        Used to simulate keyboard actions
    mqttc: `paho.mqtt.client.Client`
        MQTT client
    config: `MQTTControllerManager`
        Configuration manager, used to configure instances of this class
    &#34;&#34;&#34;

    volume_schema = {
        &#34;type&#34;: &#34;object&#34;,
        &#34;properties&#34;: {&#34;volume&#34;: {&#34;type&#34;: &#34;integer&#34;, &#34;minimum&#34;: 0, &#34;maximum&#34;: 100}},
    }

    volume_ctrl_schema = {
        &#34;type&#34;: &#34;object&#34;,
        &#34;properties&#34;: {&#34;volumeCtrl&#34;: {&#34;type&#34;: &#34;string&#34;, &#34;enum&#34;: [&#34;+&#34;, &#34;-&#34;]}},
    }

    mute_schema = {
        &#34;type&#34;: &#34;object&#34;,
        &#34;properties&#34;: {&#34;mute&#34;: {&#34;type&#34;: &#34;boolean&#34;}},
    }

    toggle_schema = {
        &#34;type&#34;: &#34;object&#34;,
        &#34;properties&#34;: {&#34;toggle&#34;: {&#34;type&#34;: &#34;string&#34;, &#34;enum&#34;: [&#34;mute&#34;, &#34;pause&#34;]}},
    }

    ctrl_schema = {
        &#34;type&#34;: &#34;object&#34;,
        &#34;properties&#34;: {&#34;ctrl&#34;: {&#34;type&#34;: &#34;string&#34;, &#34;enum&#34;: [&#34;&gt;&gt;&#34;, &#34;&lt;&lt;&#34;]}},
    }

    def __init__(self):
        # to run the unittest in an environment without an audio device
        try:
            self.audio_mixer = ALSAMixer()
        except ALSAAudioError as alsa_error:
            if __name__ == &#34;__main__&#34;:
                raise
            else:
                print(f&#34;No audio device: {alsa_error}&#34;)
                self.audio_mixer = None
        self.keyboard = KeyboardController() if KeyboardController else None
        self.mqttc = mqtt.Client()
        self.mqttc.on_connect = self.on_connect
        self.mqttc.on_publish = self.on_publish
        self.mqttc.on_subscribe = self.on_subscribe
        self.mqttc.on_message = self.on_message
        self.mqttc.on_disconnect = self.on_disconnect
        self.config = MQTTControllerManager()

    def on_connect(
        self,
        client: mqtt.Client,
        userdata: Any,
        flags: dict,
        rc: int,
        properties: Properties = None,
    ) -&gt; None:
        &#34;&#34;&#34;Defines the `on_connect` callback implementation.

        See `paho.mqtt.client.Client.on_connect` for more information.
        &#34;&#34;&#34;
        if rc == 0:
            logging.info(
                f&#34;Successfully connected to the broker {self.config.broker}: flags={flags}, properties={properties}&#34;
            )
        else:
            logging.error(
                f&#34;Cannot connect to the broker {self.config.broker}: error code={rc}&#34;
            )

    @staticmethod
    def on_publish(client: mqtt.Client, userdata: Any, mid: int) -&gt; None:
        &#34;&#34;&#34;Defines the `on_publish` callback implementation.

        See `paho.mqtt.client.Client.on_publish` for more information.
        &#34;&#34;&#34;
        logging.info(f&#34;Successfully published a message: mid={mid}&#34;)

    @staticmethod
    def on_subscribe(
        client: mqtt.Client,
        userdata: Any,
        mid: int,
        granted_qos: int,
        properties: Properties = None,
    ) -&gt; None:
        &#34;&#34;&#34;Defines the `on_subscribe` callback implementation.

        See `paho.mqtt.client.Client.on_subscribe` for more information.
        &#34;&#34;&#34;
        logging.info(
            f&#34;Successfully subscribed to topic: mid={mid}, granted qos={granted_qos}, properties={properties}&#34;
        )

    def handle_message(self, msg: mqtt.MQTTMessage) -&gt; None:
        &#34;&#34;&#34;Processes the received message and performs the corresponding action.

        Parameters
        ----------
        msg: `paho.mqtt.client.MQTTMessage`
            The received message to process

        Raises
        ------
        UnicodeDecodeError
            if message decoding fails
        JSONDecodeError
            if message JSON decoding fails
        ValidationError
            if message JSON Schema validation fails
        ValueError
            if message contains an invalid command
        &#34;&#34;&#34;
        payload = json.loads(msg.payload.decode(&#34;utf-8&#34;))
        logging.info(f&#34;Received a new message: {payload}&#34;)
        if &#34;volume&#34; in payload:
            validate(payload, schema=self.volume_schema)
            self.volume = payload[&#34;volume&#34;]
        elif &#34;volumeCtrl&#34; in payload:
            validate(payload, schema=self.volume_ctrl_schema)
            self.volume_up() if payload[&#34;volumeCtrl&#34;] == &#34;+&#34; else self.volume_down()
        elif &#34;mute&#34; in payload:
            validate(payload, schema=self.mute_schema)
            self.mute = payload[&#34;mute&#34;]
        elif &#34;toggle&#34; in payload:
            validate(payload, schema=self.toggle_schema)
            self.toggle_mute() if payload[&#34;toggle&#34;] == &#34;mute&#34; else self.toggle_pause()
        elif &#34;ctrl&#34; in payload:
            validate(payload, schema=self.ctrl_schema)
            self.skip_forward() if payload[&#34;ctrl&#34;] == &#34;&gt;&gt;&#34; else self.skip_backward()
        else:
            raise ValueError(f&#34;Cannot handle message: {payload}, not a valid command&#34;)

    def on_message(
        self, client: mqtt.Client, userdata: Any, msg: mqtt.MQTTMessage
    ) -&gt; None:
        &#34;&#34;&#34;Defines the `on_message` callback implementation.

        See `paho.mqtt.client.Client.on_message` for more information.
        &#34;&#34;&#34;
        try:
            self.handle_message(msg)
        except UnicodeDecodeError as e:
            logging.error(f&#34;Cannot decode message: {msg.payload}, {e}&#34;)
        except JSONDecodeError:
            logging.error(
                f&#34;Cannot deserialize message: {msg.payload.decode(&#39;utf-8&#39;)}, not a valid JSON&#34;
            )
        except ValidationError as e:
            logging.error(f&#34;Invalid JSON Schema: {e.message}&#34;)
        except ValueError as e:
            logging.error(str(e))
        except Exception as e:
            logging.error(f&#34;Unexpected error while receiving a new message: {e}&#34;)

    def on_disconnect(self, client: mqtt.Client, userdata: Any, rc: int) -&gt; None:
        &#34;&#34;&#34;Defines the `on_disconnect` callback implementation.

        See `paho.mqtt.client.Client.on_disconnect` for more information.
        &#34;&#34;&#34;
        if rc == mqtt.MQTT_ERR_SUCCESS:
            logging.info(
                f&#34;Successfully disconnected from the broker {self.config.broker}&#34;
            )
            sys.exit(0)
        else:
            logging.critical(
                f&#34;Unexpected disconnection from the broker {self.config.broker}: error code={rc}&#34;
            )
            sys.exit(1)

    @property
    def volume(self) -&gt; int:
        &#34;&#34;&#34;Gets the current volume.

        Returns
        -------
        int
            current volume integer percentage
        &#34;&#34;&#34;
        return self.audio_mixer.getvolume()[0]

    @volume.setter
    def volume(self, value: int) -&gt; None:
        &#34;&#34;&#34;Sets the volume.

        Parameters
        ----------
        value: int
            volume integer percentage
        &#34;&#34;&#34;
        self.audio_mixer.setvolume(value)
        self.update_status()

    def volume_up(self) -&gt; None:
        &#34;&#34;&#34;Increases the volume.

        The volume is increased by `VOLUME_STEP`, given in the configurations file.
        &#34;&#34;&#34;
        self.volume = min(self.volume + self.config.volume_step, 100)

    def volume_down(self) -&gt; None:
        &#34;&#34;&#34;Decreases the volume.

        The volume is decreased by `VOLUME_STEP`, given in the configurations file.
        &#34;&#34;&#34;
        self.volume = max(self.volume - self.config.volume_step, 0)

    @property
    def mute(self) -&gt; bool:
        &#34;&#34;&#34;Gets the mute status.

        Returns
        -------
        bool
            True if mute, False otherwise
        &#34;&#34;&#34;
        return bool(self.audio_mixer.getmute()[0])

    @mute.setter
    def mute(self, value: bool) -&gt; None:
        &#34;&#34;&#34;Sets the mute status.

        Parameters
        ----------
        value: bool
            updated mute status
        &#34;&#34;&#34;
        self.audio_mixer.setmute(value)
        self.update_status()

    def toggle_mute(self) -&gt; None:
        &#34;&#34;&#34;Toggle mute status.&#34;&#34;&#34;
        self.mute = not self.mute

    def toggle_pause(self) -&gt; None:
        &#34;&#34;&#34;Toggle play/pause status by simulating a space bar press.&#34;&#34;&#34;
        self.keyboard.press(Key.space)
        self.keyboard.release(Key.space)

    def skip_forward(self) -&gt; None:
        &#34;&#34;&#34;Skip forward.

        How much the content will be skipped forward is platform dependant (usually 10 seconds).
        &#34;&#34;&#34;
        self.keyboard.press(Key.right)
        self.keyboard.release(Key.right)

    def skip_backward(self) -&gt; None:
        &#34;&#34;&#34;Skip backward.

        How much the content will be skipped backward is platform dependant (usually 10 seconds).
        &#34;&#34;&#34;
        self.keyboard.press(Key.left)
        self.keyboard.release(Key.left)

    @property
    def status(self) -&gt; dict:
        &#34;&#34;&#34;Gets the current status.

        Returns
        -------
        dict
            a dictionary containing the current volume/mute status

        Notes
        -----
        `play/pause` status is not included here because there is no way
        to actually maintain an always up-to-date status.
        &#34;&#34;&#34;
        return {&#34;volume&#34;: self.volume, &#34;mute&#34;: self.mute}

    def update_status(self) -&gt; None:
        &#34;&#34;&#34;Publishes on `MQTT_STATUS_TOPIC` the current status (volume/mute).&#34;&#34;&#34;
        try:
            (rc, mid) = self.mqttc.publish(
                self.config.status_topic, json.dumps(self.status), qos=0, retain=False
            )
            if rc == mqtt.MQTT_ERR_SUCCESS:
                logging.info(
                    f&#34;The request for a status update has been successfully accepted: mid={mid}&#34;
                )
            else:
                logging.warning(&#34;The request for a status update has been rejected&#34;)
        except ValueError as e:
            logging.warning(f&#34;Cannot send status update: {e}&#34;)

    def start(self) -&gt; None:
        &#34;&#34;&#34;Starts the MQTT client and subscribes to `MQTT_CONTROL_TOPIC` to receive commands.&#34;&#34;&#34;
        # Set logging level
        debug_level = logging.DEBUG if self.config.debug else logging.ERROR
        logging.basicConfig(
            format=&#34;[%(asctime)s] %(levelname)-8s %(message)s&#34;, level=debug_level
        )

        try:
            # Check if authentication is required for connecting to the broker
            if self.config.user and self.config.password:
                self.mqttc.username_pw_set(
                    username=self.config.user, password=self.config.password
                )

            # Connect to the broker
            self.mqttc.connect(self.config.broker, self.config.port, keepalive=60)

            # Subscribe to the control topic, used to receive commands
            (rc, mid) = self.mqttc.subscribe(self.config.control_topic, qos=0)
            if rc == mqtt.MQTT_ERR_SUCCESS:
                logging.info(
                    f&#34;The request for control topic subscription has been successfully accepted: mid={mid}&#34;
                )
            else:
                logging.warning(
                    &#34;The request for control topic subscription has been rejected&#34;
                )

            # Check if status updates should be sent periodically
            if self.config.status_update_delay:
                self.mqttc.loop_start()
                while True:
                    self.update_status()
                    time.sleep(self.config.status_update_delay)
            else:
                self.mqttc.loop_forever()
        except ConnectionError as e:
            logging.critical(f&#34;Connection failed: {e}&#34;)
            sys.exit(1)
        except ValueError as e:
            logging.critical(
                f&#34;Cannot subscribe to topic {self.config.control_topic}: {e}&#34;
            )
            sys.exit(1)
        except Exception as e:
            logging.critical(f&#34;Unexpected error while starting the controller: {e}&#34;)
            sys.exit(1)

    def stop(self) -&gt; None:
        &#34;&#34;&#34;Stops the MQTT client and disconnects from the broker.&#34;&#34;&#34;
        self.mqttc.disconnect()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="mqttrdc.mqtt_controller.MQTTController.ctrl_schema"><code class="name">var <span class="ident">ctrl_schema</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="mqttrdc.mqtt_controller.MQTTController.mute_schema"><code class="name">var <span class="ident">mute_schema</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="mqttrdc.mqtt_controller.MQTTController.toggle_schema"><code class="name">var <span class="ident">toggle_schema</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="mqttrdc.mqtt_controller.MQTTController.volume_ctrl_schema"><code class="name">var <span class="ident">volume_ctrl_schema</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="mqttrdc.mqtt_controller.MQTTController.volume_schema"><code class="name">var <span class="ident">volume_schema</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="mqttrdc.mqtt_controller.MQTTController.on_publish"><code class="name flex">
<span>def <span class="ident">on_publish</span></span>(<span>client: paho.mqtt.client.Client, userdata: Any, mid: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the <code>on_publish</code> callback implementation.</p>
<p>See <code>paho.mqtt.client.Client.on_publish</code> for more information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def on_publish(client: mqtt.Client, userdata: Any, mid: int) -&gt; None:
    &#34;&#34;&#34;Defines the `on_publish` callback implementation.

    See `paho.mqtt.client.Client.on_publish` for more information.
    &#34;&#34;&#34;
    logging.info(f&#34;Successfully published a message: mid={mid}&#34;)</code></pre>
</details>
</dd>
<dt id="mqttrdc.mqtt_controller.MQTTController.on_subscribe"><code class="name flex">
<span>def <span class="ident">on_subscribe</span></span>(<span>client: paho.mqtt.client.Client, userdata: Any, mid: int, granted_qos: int, properties: paho.mqtt.properties.Properties = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the <code>on_subscribe</code> callback implementation.</p>
<p>See <code>paho.mqtt.client.Client.on_subscribe</code> for more information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def on_subscribe(
    client: mqtt.Client,
    userdata: Any,
    mid: int,
    granted_qos: int,
    properties: Properties = None,
) -&gt; None:
    &#34;&#34;&#34;Defines the `on_subscribe` callback implementation.

    See `paho.mqtt.client.Client.on_subscribe` for more information.
    &#34;&#34;&#34;
    logging.info(
        f&#34;Successfully subscribed to topic: mid={mid}, granted qos={granted_qos}, properties={properties}&#34;
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="mqttrdc.mqtt_controller.MQTTController.mute"><code class="name">var <span class="ident">mute</span> : bool</code></dt>
<dd>
<div class="desc"><p>Gets the mute status.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if mute, False otherwise</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mute(self) -&gt; bool:
    &#34;&#34;&#34;Gets the mute status.

    Returns
    -------
    bool
        True if mute, False otherwise
    &#34;&#34;&#34;
    return bool(self.audio_mixer.getmute()[0])</code></pre>
</details>
</dd>
<dt id="mqttrdc.mqtt_controller.MQTTController.status"><code class="name">var <span class="ident">status</span> : dict</code></dt>
<dd>
<div class="desc"><p>Gets the current status.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>a dictionary containing the current volume/mute status</dd>
</dl>
<h2 id="notes">Notes</h2>
<p><code>play/pause</code> status is not included here because there is no way
to actually maintain an always up-to-date status.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def status(self) -&gt; dict:
    &#34;&#34;&#34;Gets the current status.

    Returns
    -------
    dict
        a dictionary containing the current volume/mute status

    Notes
    -----
    `play/pause` status is not included here because there is no way
    to actually maintain an always up-to-date status.
    &#34;&#34;&#34;
    return {&#34;volume&#34;: self.volume, &#34;mute&#34;: self.mute}</code></pre>
</details>
</dd>
<dt id="mqttrdc.mqtt_controller.MQTTController.volume"><code class="name">var <span class="ident">volume</span> : int</code></dt>
<dd>
<div class="desc"><p>Gets the current volume.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>current volume integer percentage</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def volume(self) -&gt; int:
    &#34;&#34;&#34;Gets the current volume.

    Returns
    -------
    int
        current volume integer percentage
    &#34;&#34;&#34;
    return self.audio_mixer.getvolume()[0]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mqttrdc.mqtt_controller.MQTTController.handle_message"><code class="name flex">
<span>def <span class="ident">handle_message</span></span>(<span>self, msg: paho.mqtt.client.MQTTMessage) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Processes the received message and performs the corresponding action.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>msg</code></strong> :&ensp;<code>paho.mqtt.client.MQTTMessage</code></dt>
<dd>The received message to process</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>UnicodeDecodeError</code></dt>
<dd>if message decoding fails</dd>
<dt><code>JSONDecodeError</code></dt>
<dd>if message JSON decoding fails</dd>
<dt><code>ValidationError</code></dt>
<dd>if message JSON Schema validation fails</dd>
<dt><code>ValueError</code></dt>
<dd>if message contains an invalid command</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_message(self, msg: mqtt.MQTTMessage) -&gt; None:
    &#34;&#34;&#34;Processes the received message and performs the corresponding action.

    Parameters
    ----------
    msg: `paho.mqtt.client.MQTTMessage`
        The received message to process

    Raises
    ------
    UnicodeDecodeError
        if message decoding fails
    JSONDecodeError
        if message JSON decoding fails
    ValidationError
        if message JSON Schema validation fails
    ValueError
        if message contains an invalid command
    &#34;&#34;&#34;
    payload = json.loads(msg.payload.decode(&#34;utf-8&#34;))
    logging.info(f&#34;Received a new message: {payload}&#34;)
    if &#34;volume&#34; in payload:
        validate(payload, schema=self.volume_schema)
        self.volume = payload[&#34;volume&#34;]
    elif &#34;volumeCtrl&#34; in payload:
        validate(payload, schema=self.volume_ctrl_schema)
        self.volume_up() if payload[&#34;volumeCtrl&#34;] == &#34;+&#34; else self.volume_down()
    elif &#34;mute&#34; in payload:
        validate(payload, schema=self.mute_schema)
        self.mute = payload[&#34;mute&#34;]
    elif &#34;toggle&#34; in payload:
        validate(payload, schema=self.toggle_schema)
        self.toggle_mute() if payload[&#34;toggle&#34;] == &#34;mute&#34; else self.toggle_pause()
    elif &#34;ctrl&#34; in payload:
        validate(payload, schema=self.ctrl_schema)
        self.skip_forward() if payload[&#34;ctrl&#34;] == &#34;&gt;&gt;&#34; else self.skip_backward()
    else:
        raise ValueError(f&#34;Cannot handle message: {payload}, not a valid command&#34;)</code></pre>
</details>
</dd>
<dt id="mqttrdc.mqtt_controller.MQTTController.on_connect"><code class="name flex">
<span>def <span class="ident">on_connect</span></span>(<span>self, client: paho.mqtt.client.Client, userdata: Any, flags: dict, rc: int, properties: paho.mqtt.properties.Properties = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the <code>on_connect</code> callback implementation.</p>
<p>See <code>paho.mqtt.client.Client.on_connect</code> for more information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_connect(
    self,
    client: mqtt.Client,
    userdata: Any,
    flags: dict,
    rc: int,
    properties: Properties = None,
) -&gt; None:
    &#34;&#34;&#34;Defines the `on_connect` callback implementation.

    See `paho.mqtt.client.Client.on_connect` for more information.
    &#34;&#34;&#34;
    if rc == 0:
        logging.info(
            f&#34;Successfully connected to the broker {self.config.broker}: flags={flags}, properties={properties}&#34;
        )
    else:
        logging.error(
            f&#34;Cannot connect to the broker {self.config.broker}: error code={rc}&#34;
        )</code></pre>
</details>
</dd>
<dt id="mqttrdc.mqtt_controller.MQTTController.on_disconnect"><code class="name flex">
<span>def <span class="ident">on_disconnect</span></span>(<span>self, client: paho.mqtt.client.Client, userdata: Any, rc: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the <code>on_disconnect</code> callback implementation.</p>
<p>See <code>paho.mqtt.client.Client.on_disconnect</code> for more information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_disconnect(self, client: mqtt.Client, userdata: Any, rc: int) -&gt; None:
    &#34;&#34;&#34;Defines the `on_disconnect` callback implementation.

    See `paho.mqtt.client.Client.on_disconnect` for more information.
    &#34;&#34;&#34;
    if rc == mqtt.MQTT_ERR_SUCCESS:
        logging.info(
            f&#34;Successfully disconnected from the broker {self.config.broker}&#34;
        )
        sys.exit(0)
    else:
        logging.critical(
            f&#34;Unexpected disconnection from the broker {self.config.broker}: error code={rc}&#34;
        )
        sys.exit(1)</code></pre>
</details>
</dd>
<dt id="mqttrdc.mqtt_controller.MQTTController.on_message"><code class="name flex">
<span>def <span class="ident">on_message</span></span>(<span>self, client: paho.mqtt.client.Client, userdata: Any, msg: paho.mqtt.client.MQTTMessage) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the <code>on_message</code> callback implementation.</p>
<p>See <code>paho.mqtt.client.Client.on_message</code> for more information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_message(
    self, client: mqtt.Client, userdata: Any, msg: mqtt.MQTTMessage
) -&gt; None:
    &#34;&#34;&#34;Defines the `on_message` callback implementation.

    See `paho.mqtt.client.Client.on_message` for more information.
    &#34;&#34;&#34;
    try:
        self.handle_message(msg)
    except UnicodeDecodeError as e:
        logging.error(f&#34;Cannot decode message: {msg.payload}, {e}&#34;)
    except JSONDecodeError:
        logging.error(
            f&#34;Cannot deserialize message: {msg.payload.decode(&#39;utf-8&#39;)}, not a valid JSON&#34;
        )
    except ValidationError as e:
        logging.error(f&#34;Invalid JSON Schema: {e.message}&#34;)
    except ValueError as e:
        logging.error(str(e))
    except Exception as e:
        logging.error(f&#34;Unexpected error while receiving a new message: {e}&#34;)</code></pre>
</details>
</dd>
<dt id="mqttrdc.mqtt_controller.MQTTController.skip_backward"><code class="name flex">
<span>def <span class="ident">skip_backward</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Skip backward.</p>
<p>How much the content will be skipped backward is platform dependant (usually 10 seconds).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skip_backward(self) -&gt; None:
    &#34;&#34;&#34;Skip backward.

    How much the content will be skipped backward is platform dependant (usually 10 seconds).
    &#34;&#34;&#34;
    self.keyboard.press(Key.left)
    self.keyboard.release(Key.left)</code></pre>
</details>
</dd>
<dt id="mqttrdc.mqtt_controller.MQTTController.skip_forward"><code class="name flex">
<span>def <span class="ident">skip_forward</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Skip forward.</p>
<p>How much the content will be skipped forward is platform dependant (usually 10 seconds).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skip_forward(self) -&gt; None:
    &#34;&#34;&#34;Skip forward.

    How much the content will be skipped forward is platform dependant (usually 10 seconds).
    &#34;&#34;&#34;
    self.keyboard.press(Key.right)
    self.keyboard.release(Key.right)</code></pre>
</details>
</dd>
<dt id="mqttrdc.mqtt_controller.MQTTController.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Starts the MQTT client and subscribes to <code>MQTT_CONTROL_TOPIC</code> to receive commands.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self) -&gt; None:
    &#34;&#34;&#34;Starts the MQTT client and subscribes to `MQTT_CONTROL_TOPIC` to receive commands.&#34;&#34;&#34;
    # Set logging level
    debug_level = logging.DEBUG if self.config.debug else logging.ERROR
    logging.basicConfig(
        format=&#34;[%(asctime)s] %(levelname)-8s %(message)s&#34;, level=debug_level
    )

    try:
        # Check if authentication is required for connecting to the broker
        if self.config.user and self.config.password:
            self.mqttc.username_pw_set(
                username=self.config.user, password=self.config.password
            )

        # Connect to the broker
        self.mqttc.connect(self.config.broker, self.config.port, keepalive=60)

        # Subscribe to the control topic, used to receive commands
        (rc, mid) = self.mqttc.subscribe(self.config.control_topic, qos=0)
        if rc == mqtt.MQTT_ERR_SUCCESS:
            logging.info(
                f&#34;The request for control topic subscription has been successfully accepted: mid={mid}&#34;
            )
        else:
            logging.warning(
                &#34;The request for control topic subscription has been rejected&#34;
            )

        # Check if status updates should be sent periodically
        if self.config.status_update_delay:
            self.mqttc.loop_start()
            while True:
                self.update_status()
                time.sleep(self.config.status_update_delay)
        else:
            self.mqttc.loop_forever()
    except ConnectionError as e:
        logging.critical(f&#34;Connection failed: {e}&#34;)
        sys.exit(1)
    except ValueError as e:
        logging.critical(
            f&#34;Cannot subscribe to topic {self.config.control_topic}: {e}&#34;
        )
        sys.exit(1)
    except Exception as e:
        logging.critical(f&#34;Unexpected error while starting the controller: {e}&#34;)
        sys.exit(1)</code></pre>
</details>
</dd>
<dt id="mqttrdc.mqtt_controller.MQTTController.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Stops the MQTT client and disconnects from the broker.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self) -&gt; None:
    &#34;&#34;&#34;Stops the MQTT client and disconnects from the broker.&#34;&#34;&#34;
    self.mqttc.disconnect()</code></pre>
</details>
</dd>
<dt id="mqttrdc.mqtt_controller.MQTTController.toggle_mute"><code class="name flex">
<span>def <span class="ident">toggle_mute</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Toggle mute status.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_mute(self) -&gt; None:
    &#34;&#34;&#34;Toggle mute status.&#34;&#34;&#34;
    self.mute = not self.mute</code></pre>
</details>
</dd>
<dt id="mqttrdc.mqtt_controller.MQTTController.toggle_pause"><code class="name flex">
<span>def <span class="ident">toggle_pause</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Toggle play/pause status by simulating a space bar press.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_pause(self) -&gt; None:
    &#34;&#34;&#34;Toggle play/pause status by simulating a space bar press.&#34;&#34;&#34;
    self.keyboard.press(Key.space)
    self.keyboard.release(Key.space)</code></pre>
</details>
</dd>
<dt id="mqttrdc.mqtt_controller.MQTTController.update_status"><code class="name flex">
<span>def <span class="ident">update_status</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Publishes on <code>MQTT_STATUS_TOPIC</code> the current status (volume/mute).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_status(self) -&gt; None:
    &#34;&#34;&#34;Publishes on `MQTT_STATUS_TOPIC` the current status (volume/mute).&#34;&#34;&#34;
    try:
        (rc, mid) = self.mqttc.publish(
            self.config.status_topic, json.dumps(self.status), qos=0, retain=False
        )
        if rc == mqtt.MQTT_ERR_SUCCESS:
            logging.info(
                f&#34;The request for a status update has been successfully accepted: mid={mid}&#34;
            )
        else:
            logging.warning(&#34;The request for a status update has been rejected&#34;)
    except ValueError as e:
        logging.warning(f&#34;Cannot send status update: {e}&#34;)</code></pre>
</details>
</dd>
<dt id="mqttrdc.mqtt_controller.MQTTController.volume_down"><code class="name flex">
<span>def <span class="ident">volume_down</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Decreases the volume.</p>
<p>The volume is decreased by <code>VOLUME_STEP</code>, given in the configurations file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def volume_down(self) -&gt; None:
    &#34;&#34;&#34;Decreases the volume.

    The volume is decreased by `VOLUME_STEP`, given in the configurations file.
    &#34;&#34;&#34;
    self.volume = max(self.volume - self.config.volume_step, 0)</code></pre>
</details>
</dd>
<dt id="mqttrdc.mqtt_controller.MQTTController.volume_up"><code class="name flex">
<span>def <span class="ident">volume_up</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Increases the volume.</p>
<p>The volume is increased by <code>VOLUME_STEP</code>, given in the configurations file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def volume_up(self) -&gt; None:
    &#34;&#34;&#34;Increases the volume.

    The volume is increased by `VOLUME_STEP`, given in the configurations file.
    &#34;&#34;&#34;
    self.volume = min(self.volume + self.config.volume_step, 100)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#examples">Examples</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mqttrdc" href="index.html">mqttrdc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mqttrdc.mqtt_controller.MQTTController" href="#mqttrdc.mqtt_controller.MQTTController">MQTTController</a></code></h4>
<ul class="two-column">
<li><code><a title="mqttrdc.mqtt_controller.MQTTController.ctrl_schema" href="#mqttrdc.mqtt_controller.MQTTController.ctrl_schema">ctrl_schema</a></code></li>
<li><code><a title="mqttrdc.mqtt_controller.MQTTController.handle_message" href="#mqttrdc.mqtt_controller.MQTTController.handle_message">handle_message</a></code></li>
<li><code><a title="mqttrdc.mqtt_controller.MQTTController.mute" href="#mqttrdc.mqtt_controller.MQTTController.mute">mute</a></code></li>
<li><code><a title="mqttrdc.mqtt_controller.MQTTController.mute_schema" href="#mqttrdc.mqtt_controller.MQTTController.mute_schema">mute_schema</a></code></li>
<li><code><a title="mqttrdc.mqtt_controller.MQTTController.on_connect" href="#mqttrdc.mqtt_controller.MQTTController.on_connect">on_connect</a></code></li>
<li><code><a title="mqttrdc.mqtt_controller.MQTTController.on_disconnect" href="#mqttrdc.mqtt_controller.MQTTController.on_disconnect">on_disconnect</a></code></li>
<li><code><a title="mqttrdc.mqtt_controller.MQTTController.on_message" href="#mqttrdc.mqtt_controller.MQTTController.on_message">on_message</a></code></li>
<li><code><a title="mqttrdc.mqtt_controller.MQTTController.on_publish" href="#mqttrdc.mqtt_controller.MQTTController.on_publish">on_publish</a></code></li>
<li><code><a title="mqttrdc.mqtt_controller.MQTTController.on_subscribe" href="#mqttrdc.mqtt_controller.MQTTController.on_subscribe">on_subscribe</a></code></li>
<li><code><a title="mqttrdc.mqtt_controller.MQTTController.skip_backward" href="#mqttrdc.mqtt_controller.MQTTController.skip_backward">skip_backward</a></code></li>
<li><code><a title="mqttrdc.mqtt_controller.MQTTController.skip_forward" href="#mqttrdc.mqtt_controller.MQTTController.skip_forward">skip_forward</a></code></li>
<li><code><a title="mqttrdc.mqtt_controller.MQTTController.start" href="#mqttrdc.mqtt_controller.MQTTController.start">start</a></code></li>
<li><code><a title="mqttrdc.mqtt_controller.MQTTController.status" href="#mqttrdc.mqtt_controller.MQTTController.status">status</a></code></li>
<li><code><a title="mqttrdc.mqtt_controller.MQTTController.stop" href="#mqttrdc.mqtt_controller.MQTTController.stop">stop</a></code></li>
<li><code><a title="mqttrdc.mqtt_controller.MQTTController.toggle_mute" href="#mqttrdc.mqtt_controller.MQTTController.toggle_mute">toggle_mute</a></code></li>
<li><code><a title="mqttrdc.mqtt_controller.MQTTController.toggle_pause" href="#mqttrdc.mqtt_controller.MQTTController.toggle_pause">toggle_pause</a></code></li>
<li><code><a title="mqttrdc.mqtt_controller.MQTTController.toggle_schema" href="#mqttrdc.mqtt_controller.MQTTController.toggle_schema">toggle_schema</a></code></li>
<li><code><a title="mqttrdc.mqtt_controller.MQTTController.update_status" href="#mqttrdc.mqtt_controller.MQTTController.update_status">update_status</a></code></li>
<li><code><a title="mqttrdc.mqtt_controller.MQTTController.volume" href="#mqttrdc.mqtt_controller.MQTTController.volume">volume</a></code></li>
<li><code><a title="mqttrdc.mqtt_controller.MQTTController.volume_ctrl_schema" href="#mqttrdc.mqtt_controller.MQTTController.volume_ctrl_schema">volume_ctrl_schema</a></code></li>
<li><code><a title="mqttrdc.mqtt_controller.MQTTController.volume_down" href="#mqttrdc.mqtt_controller.MQTTController.volume_down">volume_down</a></code></li>
<li><code><a title="mqttrdc.mqtt_controller.MQTTController.volume_schema" href="#mqttrdc.mqtt_controller.MQTTController.volume_schema">volume_schema</a></code></li>
<li><code><a title="mqttrdc.mqtt_controller.MQTTController.volume_up" href="#mqttrdc.mqtt_controller.MQTTController.volume_up">volume_up</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>